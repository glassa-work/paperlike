<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Paperlike</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <style>
    /* ============================================================
       PAPERLIKE ‚Äî Obsidian + Excalidraw inspired
       Inline drawing blocks, keyboard-driven, minimal UI
       ============================================================ */
    :root {
      --font: 'Caveat', cursive;
      --bg: #faf8f5;
      --surface: #ffffff;
      --sidebar-bg: #1e1e2e;
      --sidebar-text: #cdd6f4;
      --sidebar-active: #89b4fa;
      --sidebar-hover: #313244;
      --border: #e8e4de;
      --text: #2c2c2c;
      --muted: #888580;
      --accent: #5b8af5;
      --accent-soft: rgba(91,138,245,0.12);
      --green: #40a06c;
      --green-soft: rgba(64,160,108,0.12);
      --red: #e64553;
      --red-soft: rgba(230,69,83,0.12);
      --orange: #df8e1d;
      --purple: #8839ef;
      --purple-soft: rgba(136,57,239,0.12);
      --canvas-dot: #ddd8d0;
      --shadow-sm: 0 2px 8px rgba(0,0,0,0.06);
      --shadow-md: 0 4px 20px rgba(0,0,0,0.1);
      --radius: 12px;
      --radius-sm: 8px;
    }

    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; overflow: hidden; }

    body {
      font-family: var(--font);
      font-size: 1.25rem;
      color: var(--text);
      background: var(--bg);
      display: flex;
    }

    /* ===== SIDEBAR ===== */
    .sidebar {
      width: 220px;
      background: var(--sidebar-bg);
      color: var(--sidebar-text);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      user-select: none;
      z-index: 10;
    }

    .sidebar-brand {
      padding: 20px 18px 16px;
      font-size: 1.5rem;
      font-weight: 700;
      color: #fff;
      border-bottom: 1px solid #313244;
    }

    .sidebar-nav { flex: 1; padding: 8px; overflow-y: auto; }

    .sidebar-item {
      display: flex; align-items: center; gap: 10px;
      padding: 10px 14px; border-radius: var(--radius-sm);
      cursor: pointer; font-size: 1.1rem; color: var(--sidebar-text);
      transition: background 0.15s;
    }
    .sidebar-item:hover { background: var(--sidebar-hover); }
    .sidebar-item.active { background: rgba(137,180,250,0.12); color: var(--sidebar-active); font-weight: 600; }

    .sidebar-section-label {
      font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.08em;
      color: #585b70; padding: 14px 14px 4px; font-weight: 600;
    }

    .sidebar-divider { height: 1px; background: #313244; margin: 6px 10px; }

    .sidebar-shortcuts {
      padding: 12px 16px; border-top: 1px solid #313244;
      font-size: 0.8rem; color: #585b70; line-height: 1.8;
    }
    .sidebar-shortcuts kbd {
      background: #313244; color: #cdd6f4; padding: 1px 6px;
      border-radius: 4px; font-family: var(--font); font-size: 0.8rem;
    }

    /* ===== MAIN AREA ===== */
    .main-area { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

    .content-scroll {
      flex: 1; overflow-y: auto; padding: 40px 0;
      scroll-behavior: smooth;
    }

    .page-view { display: none; max-width: 780px; margin: 0 auto; padding: 0 32px; }
    .page-view.active { display: block; }

    /* ===== EDITOR ===== */
    .editor-title {
      font-size: 3rem; font-weight: 700; line-height: 1.15;
      margin-bottom: 4px; outline: none;
    }

    .editor-meta {
      display: flex; gap: 16px; font-size: 0.95rem; color: var(--muted);
      margin-bottom: 28px; align-items: center;
    }
    .meta-dot {
      display: inline-block; width: 8px; height: 8px; border-radius: 50%;
      background: var(--green); margin-right: 4px; vertical-align: middle;
    }

    /* ===== BLOCK EDITOR ===== */
    .block-editor { min-height: 200px; }

    .block {
      position: relative; padding: 6px 12px 6px 32px;
      border-radius: var(--radius-sm); cursor: text;
      transition: background 0.12s; border: 2px solid transparent;
      margin: 2px 0;
    }
    .block:hover { background: var(--accent-soft); }
    .block.selected { border-color: var(--accent); background: var(--accent-soft); }

    .block .handle {
      position: absolute; left: 6px; top: 50%; transform: translateY(-50%);
      color: var(--muted); font-size: 0.9rem; cursor: grab;
      opacity: 0; transition: opacity 0.15s;
    }
    .block:hover .handle { opacity: 0.5; }

    .block p { line-height: 1.6; }
    .block h1 { font-size: 2.2rem; font-weight: 700; line-height: 1.2; }
    .block h2 { font-size: 1.8rem; font-weight: 600; line-height: 1.25; }
    .block h3 { font-size: 1.5rem; font-weight: 600; line-height: 1.3; }
    .block ul, .block ol { padding-left: 24px; line-height: 1.7; }
    .block li { margin: 2px 0; }

    .spacer-line {
      height: 1px; background: var(--border); margin: 16px 0;
    }

    .section-badge {
      display: inline-block; background: var(--purple-soft); color: var(--purple);
      padding: 4px 14px; border-radius: 20px; font-size: 0.95rem;
    }

    .add-block-line {
      text-align: center; padding: 12px 0;
    }
    .add-block-line button {
      background: none; border: 2px dashed var(--border); color: var(--muted);
      padding: 8px 24px; border-radius: var(--radius); cursor: pointer;
      font-family: var(--font); font-size: 1.1rem; transition: all 0.15s;
    }
    .add-block-line button:hover {
      border-color: var(--accent); color: var(--accent); background: var(--accent-soft);
    }

    /* ===== INLINE DRAWING BLOCK ===== */
    .drawing-block-wrapper {
      position: relative; margin: 8px 0; border-radius: var(--radius);
      border: 2px solid transparent; transition: border-color 0.15s;
    }
    .drawing-block-wrapper:hover { border-color: var(--border); }
    .drawing-block-wrapper.editing { border-color: var(--accent); }

    .drawing-canvas-inline {
      position: relative; width: 100%; min-height: 120px;
      background-color: #fefefe; border-radius: var(--radius-sm);
      overflow: hidden; cursor: default;
      background-image: radial-gradient(circle, var(--canvas-dot) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    .drawing-canvas-inline .canvas-element {
      position: absolute; border: 2px solid; display: flex;
      align-items: center; justify-content: center;
      font-size: 1rem; transition: box-shadow 0.12s;
      cursor: pointer; user-select: none;
    }
    .drawing-canvas-inline .canvas-element.selected {
      box-shadow: 0 0 0 3px var(--accent);
    }

    .drawing-view-overlay {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      cursor: pointer; z-index: 2;
    }
    .drawing-block-wrapper.editing .drawing-view-overlay { display: none; }

    .drawing-click-hint {
      position: absolute; bottom: 8px; right: 12px;
      font-size: 0.8rem; color: var(--muted); opacity: 0;
      transition: opacity 0.15s; pointer-events: none; z-index: 3;
    }
    .drawing-block-wrapper:hover:not(.editing) .drawing-click-hint { opacity: 1; }

    /* Drawing floating toolbar - only visible when editing */
    .drawing-float-toolbar {
      position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
      display: none; background: var(--surface); border-radius: 28px;
      padding: 4px 8px; box-shadow: var(--shadow-md); z-index: 5;
      gap: 2px; align-items: center;
    }
    .drawing-block-wrapper.editing .drawing-float-toolbar { display: flex; }

    .drawing-float-toolbar button {
      background: none; border: none; padding: 6px 10px; border-radius: 20px;
      cursor: pointer; font-family: var(--font); font-size: 1rem;
      color: var(--text); transition: background 0.12s;
    }
    .drawing-float-toolbar button:hover { background: var(--accent-soft); }
    .drawing-float-toolbar button:disabled { opacity: 0.3; cursor: default; }
    .drawing-float-toolbar button:disabled:hover { background: none; }
    .drawing-float-toolbar .sep { width: 1px; height: 20px; background: var(--border); margin: 0 4px; }

    .drawing-status-bar {
      display: none; font-size: 0.8rem; color: var(--muted);
      padding: 4px 12px; text-align: right;
    }
    .drawing-block-wrapper.editing .drawing-status-bar { display: block; }

    /* Resize handle */
    .drawing-resize-handle {
      height: 8px; cursor: ns-resize; display: flex;
      justify-content: center; align-items: center;
      opacity: 0; transition: opacity 0.15s;
    }
    .drawing-block-wrapper:hover .drawing-resize-handle,
    .drawing-block-wrapper.editing .drawing-resize-handle { opacity: 1; }

    .drawing-resize-handle::after {
      content: ''; width: 40px; height: 4px;
      background: var(--border); border-radius: 2px;
    }

    .empty { text-align: center; padding: 32px; color: var(--muted); font-size: 1.15rem; }

    /* ===== LOG PANEL ===== */
    .log-panel {
      margin-top: 20px; background: #1e1e2e; color: #a6adc8;
      border-radius: var(--radius); padding: 10px 14px;
      font-size: 0.85rem; max-height: 140px; overflow-y: auto;
      font-family: var(--font);
    }
    .log-line { padding: 2px 0; display: flex; gap: 10px; }
    .log-ts { color: #585b70; min-width: 70px; }
    .log-msg { color: #cdd6f4; }

    /* ===== COMMENTS ===== */
    .page-title { font-size: 2.6rem; font-weight: 700; margin-bottom: 6px; }
    .page-subtitle { font-size: 1.15rem; color: var(--muted); margin-bottom: 32px; line-height: 1.5; }

    .two-panel { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }

    .device-panel {
      background: var(--surface); border-radius: var(--radius);
      padding: 16px; border: 1px solid var(--border);
    }
    .device-label {
      font-weight: 600; font-size: 1.1rem; margin-bottom: 12px;
      display: flex; align-items: center; gap: 8px;
    }
    .sync-badge {
      font-size: 0.75rem; padding: 2px 10px; border-radius: 12px; font-weight: 500;
    }
    .sync-badge.synced { background: var(--green-soft); color: var(--green); }
    .sync-badge.pending { background: rgba(223,142,29,0.12); color: var(--orange); }
    .sync-badge.offline { background: var(--red-soft); color: var(--red); }

    .comment-thread {
      padding: 10px 12px; border-radius: var(--radius-sm);
      background: var(--bg); margin-bottom: 8px;
    }
    .comment-author-name { font-weight: 600; }
    .comment-on { font-size: 0.85rem; color: var(--muted); margin-left: 6px; }
    .comment-body { margin-top: 4px; line-height: 1.5; font-size: 1.05rem; }

    /* ===== COLUMNS ===== */
    .columns-layout {
      display: flex; gap: 12px; margin-bottom: 16px;
      background: var(--surface); border-radius: var(--radius);
      padding: 14px; border: 1px solid var(--border);
    }
    .col-lane {
      flex: 1; padding: 10px; background: var(--bg);
      border-radius: var(--radius-sm); border: 1px solid var(--border);
    }
    .col-lane-label {
      font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.06em;
      color: var(--muted); margin-bottom: 8px; font-weight: 600;
    }
    .col-lane-block {
      padding: 8px 10px; background: var(--surface);
      border-radius: var(--radius-sm); margin-bottom: 6px;
      border: 1px solid var(--border); font-size: 1.05rem;
    }

    .empty-dashed {
      text-align: center; padding: 40px; color: var(--muted); font-size: 1.2rem;
      border: 2px dashed var(--border); border-radius: var(--radius);
    }

    /* ===== EXPORT ===== */
    .export-terminal {
      background: #1e1e2e; color: #a6adc8; border-radius: var(--radius);
      padding: 20px; font-family: var(--font); font-size: 0.9rem;
      white-space: pre-wrap; word-break: break-all; max-height: 500px;
      overflow-y: auto; line-height: 1.5;
    }

    /* ===== FLOATING TOOLBARS ===== */
    .float-toolbar {
      position: fixed; bottom: 24px; left: 50%; transform: translateX(-50%);
      background: var(--surface); border-radius: 28px; padding: 6px 12px;
      box-shadow: var(--shadow-md); display: none; gap: 4px;
      align-items: center; z-index: 100; border: 1px solid var(--border);
    }
    .float-toolbar.visible { display: flex; }

    .float-toolbar button {
      background: none; border: none; padding: 8px 14px;
      border-radius: 20px; cursor: pointer; font-family: var(--font);
      font-size: 1.05rem; color: var(--text); transition: background 0.12s;
      white-space: nowrap;
    }
    .float-toolbar button:hover { background: var(--accent-soft); }
    .float-toolbar .separator { width: 1px; height: 22px; background: var(--border); margin: 0 2px; }
    .float-toolbar .danger-tool:hover { background: var(--red-soft); color: var(--red); }
  </style>
</head>
<body>

<!-- ===== SIDEBAR ===== -->
<div class="sidebar">
  <div class="sidebar-brand">üìù Paperlike</div>
  <nav class="sidebar-nav">
    <div class="sidebar-section-label">Document</div>
    <div class="sidebar-item active" data-page="editor" onclick="showPage('editor')">
      <span class="nav-icon">üìÑ</span> Editor
    </div>
    <div class="sidebar-item" data-page="comments" onclick="showPage('comments')">
      <span class="nav-icon">üí¨</span> Comments
    </div>
    <div class="sidebar-divider"></div>
    <div class="sidebar-section-label">Layout</div>
    <div class="sidebar-item" data-page="columns" onclick="showPage('columns')">
      <span class="nav-icon">üìä</span> Columns
    </div>
    <div class="sidebar-divider"></div>
    <div class="sidebar-section-label">File</div>
    <div class="sidebar-item" data-page="export" onclick="showPage('export')">
      <span class="nav-icon">üì¶</span> Export
    </div>
  </nav>
  <div class="sidebar-shortcuts">
    <div><kbd>Ctrl</kbd>+<kbd>P</kbd> paragraph</div>
    <div><kbd>Ctrl</kbd>+<kbd>H</kbd> heading</div>
    <div><kbd>Ctrl</kbd>+<kbd>L</kbd> list</div>
    <div><kbd>Ctrl</kbd>+<kbd>D</kbd> drawing</div>
    <div><kbd>Ctrl</kbd>+<kbd>E</kbd> edit block</div>
    <div><kbd>Del</kbd> delete block</div>
    <div><kbd>‚Üë</kbd>/<kbd>‚Üì</kbd> move block</div>
    <div><kbd>Esc</kbd> deselect / close</div>
  </div>
</div>

<!-- ===== MAIN ===== -->
<div class="main-area">
  <div class="content-scroll">

    <!-- EDITOR PAGE -->
    <div class="page-view active" id="page-editor">
      <div class="editor-title">Welcome to Paperlike</div>
      <div class="editor-meta">
        <span><span class="meta-dot"></span> Lease active</span>
        <span>Version <strong id="doc-version">0</strong></span>
        <span><strong id="block-count">0</strong> blocks</span>
      </div>
      <div class="block-editor" id="block-editor"></div>
      <div class="add-block-line">
        <button onclick="addParagraph()">+ add block</button>
      </div>
      <div class="log-panel" id="body-log">
        <div class="log-line"><span class="log-ts">ready</span><span class="log-msg">editor initialized</span></div>
      </div>
    </div>

    <!-- COMMENTS PAGE -->
    <div class="page-view" id="page-comments">
      <div class="page-title">Comments</div>
      <div class="page-subtitle">CRDT-powered ‚Äî offline edits from multiple devices merge automatically</div>
      <div class="two-panel">
        <div class="device-panel">
          <div class="device-label">üì± Device A <span class="sync-badge synced" id="sync-a">synced</span></div>
          <div id="comments-a"><div class="empty">no comments yet</div></div>
        </div>
        <div class="device-panel">
          <div class="device-label">üíª Device B <span class="sync-badge synced" id="sync-b">synced</span></div>
          <div id="comments-b"><div class="empty">no comments yet</div></div>
        </div>
      </div>
    </div>

    <!-- COLUMNS PAGE -->
    <div class="page-view" id="page-columns">
      <div class="page-title">Column Sections</div>
      <div class="page-subtitle">Recursive lane-based layouts ‚Äî sections nest inside sections</div>
      <div id="columns-area">
        <div class="empty-dashed">add a column layout below</div>
      </div>
    </div>

    <!-- EXPORT PAGE -->
    <div class="page-view" id="page-export">
      <div class="page-title">Export / Import</div>
      <div class="page-subtitle">.paperlike bundle ‚Äî body.json, drawings, comments, manifest</div>
      <div class="export-terminal" id="export-preview">click "export" in the toolbar to see the serialized bundle</div>
    </div>

  </div>
</div>

<!-- ===== FLOATING TOOLBARS ===== -->
<div class="float-toolbar visible" id="toolbar-editor">
  <button onclick="addParagraph()" title="Paragraph (Ctrl+P)">¬∂</button>
  <button onclick="addHeading()" title="Heading (Ctrl+H)">H</button>
  <button onclick="addList()" title="List (Ctrl+L)">‚ò∞</button>
  <button onclick="addDrawingBlock()" title="Drawing (Ctrl+D)">üñº</button>
  <button onclick="addSpacer()" title="Spacer">‚Äî</button>
  <div class="separator"></div>
  <button onclick="updateSelected()" title="Edit (Ctrl+E)">‚úé</button>
  <button onclick="moveSelectedUp()" title="Move up (‚Üë)">‚Üë</button>
  <button onclick="moveSelectedDown()" title="Move down (‚Üì)">‚Üì</button>
  <button class="danger-tool" onclick="deleteSelected()" title="Delete (Del)">‚úï</button>
</div>

<div class="float-toolbar" id="toolbar-comments">
  <button onclick="addCommentA()" title="Alice comments">üë© Alice</button>
  <button onclick="addCommentB()" title="Bob comments">üë® Bob</button>
  <div class="separator"></div>
  <button onclick="syncComments()" title="Sync">üîÑ sync</button>
  <button onclick="goOffline()" title="Go offline">üì¥</button>
  <button onclick="goOnline()" title="Go online">üì∂</button>
</div>

<div class="float-toolbar" id="toolbar-columns">
  <button onclick="addTwoColumns()">2 columns</button>
  <button onclick="addThreeColumns()">3 columns</button>
  <button onclick="addNestedSection()">nested</button>
</div>

<div class="float-toolbar" id="toolbar-export">
  <button onclick="exportBundle()">üì§ export</button>
  <button onclick="reimportBundle()">üì• re-import</button>
</div>

<script>
// =========================================================================
// PAPERLIKE DEMO ‚Äî Inline drawing blocks, keyboard-driven
// =========================================================================

// --- Navigation ---
let currentPage = 'editor';

function showPage(name) {
  currentPage = name;
  document.querySelectorAll('.page-view').forEach(p => p.classList.remove('active'));
  document.getElementById('page-' + name).classList.add('active');
  document.querySelectorAll('.sidebar-item').forEach(s => {
    s.classList.toggle('active', s.dataset.page === name);
  });
  document.querySelectorAll('.float-toolbar').forEach(t => t.classList.remove('visible'));
  const tb = document.getElementById('toolbar-' + name);
  if (tb) tb.classList.add('visible');
}

// --- Branded ID helpers ---
let idCounter = 0;
const makeId = (prefix) => `${prefix}-${++idCounter}`;

// --- State ---
let blocks = [];
let selectedBlockId = null;
let docVersion = 0;

// Each drawing block has its own state keyed by drawingId
const drawingStates = {};

let commentsOnline = true;
let pendingA = [];
let pendingB = [];
let commentsA = [];
let commentsB = [];
let commentCounterA = 0;
let commentCounterB = 0;

const sampleTexts = [
  "This paragraph needs more detail",
  "Great point, well articulated",
  "Consider adding an example here",
  "The drawing should include labels",
  "This section is ready for review",
  "Can we simplify this wording?",
  "Nice layout structure!",
  "Let's add more context",
];

const sampleParas = [
  "Paperlike enables collaborative document editing with real-time sync.",
  "The block-based architecture supports paragraphs, headings, lists, and embedded drawings.",
  "Each document maintains a versioned history of all changes.",
  "CRDT-based comments allow offline editing with automatic merge on reconnection.",
  "Sections support recursive column layouts for complex document structures.",
];

const sampleHeadings = [
  "Introduction",
  "Getting Started",
  "Architecture Overview",
  "API Reference",
  "Conclusion",
];

const colors = ['#5b8af5', '#e64553', '#40a06c', '#df8e1d', '#8839ef', '#ea76cb', '#179299', '#fe640b'];

// ===== DRAWING STATE MANAGEMENT =====

function getDrawingState(drawingId) {
  if (!drawingStates[drawingId]) {
    drawingStates[drawingId] = {
      elements: [],
      actions: [],
      historyState: { undoCursor: -1, actionCount: 0 },
      selectedElementId: null,
      editing: false,
      height: 220,
    };
  }
  return drawingStates[drawingId];
}

function addShapeToDrawing(drawingId, type) {
  const ds = getDrawingState(drawingId);
  const wrapper = document.querySelector(`[data-drawing-id="${drawingId}"] .drawing-canvas-inline`);
  const w = wrapper ? wrapper.clientWidth : 700;
  const h = ds.height - 50;
  const size = type === 'line'
    ? { width: 80 + Math.random() * 120, height: 0 }
    : { width: 60 + Math.random() * 100, height: 40 + Math.random() * 80 };
  const x = 20 + Math.random() * (w - size.width - 40);
  const y = 20 + Math.random() * Math.max(40, h - (size.height || 20) - 40);
  const color = colors[Math.floor(Math.random() * colors.length)];
  const bg = Math.random() > 0.4 ? color + '18' : 'transparent';

  const el = {
    id: makeId('el'),
    type,
    x: Math.round(x), y: Math.round(y),
    ...size,
    strokeColor: color,
    backgroundColor: bg,
    angle: type === 'line' ? Math.round(Math.random() * 40 - 20) : 0,
  };

  const action = {
    drawingId,
    historyGroupId: makeId('hg'),
    forward: [{ type: 'add_element', element: el }],
    inverse: [{ type: 'delete_element', elementId: el.id }],
    timestamp: Date.now(),
  };

  ds.actions = ds.actions.slice(0, ds.historyState.undoCursor + 1);
  ds.actions.push(action);
  ds.elements.push(el);
  ds.historyState = { undoCursor: ds.actions.length - 1, actionCount: ds.actions.length };
  ds.selectedElementId = el.id;
  renderDrawingBlock(drawingId);
  logBody(`draw: add ${type} in ${drawingId}`);
}

function applyDrawingPatches(drawingId, patches) {
  const ds = getDrawingState(drawingId);
  patches.forEach(patch => {
    switch (patch.type) {
      case 'add_element': ds.elements.push(patch.element); break;
      case 'delete_element': ds.elements = ds.elements.filter(e => e.id !== patch.elementId); break;
      case 'update_element': ds.elements = ds.elements.map(e => e.id === patch.elementId ? { ...e, ...patch.patch } : e); break;
    }
  });
}

function drawingUndo(drawingId) {
  const ds = getDrawingState(drawingId);
  if (ds.historyState.undoCursor < 0) return;
  const a = ds.actions[ds.historyState.undoCursor];
  if (!a) return;
  applyDrawingPatches(drawingId, a.inverse);
  ds.historyState = { ...ds.historyState, undoCursor: ds.historyState.undoCursor - 1 };
  renderDrawingBlock(drawingId);
  logBody(`draw: undo in ${drawingId}`);
}

function drawingRedo(drawingId) {
  const ds = getDrawingState(drawingId);
  if (ds.historyState.undoCursor >= ds.historyState.actionCount - 1) return;
  const a = ds.actions[ds.historyState.undoCursor + 1];
  if (!a) return;
  applyDrawingPatches(drawingId, a.forward);
  ds.historyState = { ...ds.historyState, undoCursor: ds.historyState.undoCursor + 1 };
  renderDrawingBlock(drawingId);
  logBody(`draw: redo in ${drawingId}`);
}

function deleteDrawingElement(drawingId) {
  const ds = getDrawingState(drawingId);
  if (!ds.selectedElementId) return;
  const el = ds.elements.find(e => e.id === ds.selectedElementId);
  if (!el) return;
  const action = {
    drawingId, historyGroupId: makeId('hg'),
    forward: [{ type: 'delete_element', elementId: el.id }],
    inverse: [{ type: 'add_element', element: el }],
    timestamp: Date.now(),
  };
  ds.actions = ds.actions.slice(0, ds.historyState.undoCursor + 1);
  ds.actions.push(action);
  ds.elements = ds.elements.filter(e => e.id !== ds.selectedElementId);
  ds.historyState = { undoCursor: ds.actions.length - 1, actionCount: ds.actions.length };
  ds.selectedElementId = null;
  renderDrawingBlock(drawingId);
  logBody(`draw: deleted element in ${drawingId}`);
}

function selectDrawingElement(drawingId, elementId) {
  const ds = getDrawingState(drawingId);
  ds.selectedElementId = ds.selectedElementId === elementId ? null : elementId;
  renderDrawingBlock(drawingId);
}

function enterDrawingEdit(drawingId) {
  // Close any other editing drawing
  Object.keys(drawingStates).forEach(id => {
    if (id !== drawingId && drawingStates[id].editing) {
      drawingStates[id].editing = false;
      drawingStates[id].selectedElementId = null;
      renderDrawingBlock(id);
    }
  });
  const ds = getDrawingState(drawingId);
  ds.editing = true;
  renderDrawingBlock(drawingId);
}

function exitDrawingEdit(drawingId) {
  const ds = getDrawingState(drawingId);
  ds.editing = false;
  ds.selectedElementId = null;
  renderDrawingBlock(drawingId);
}

// ===== RENDER DRAWING BLOCK =====

function renderDrawingBlock(drawingId) {
  const wrapper = document.querySelector(`[data-drawing-id="${drawingId}"]`);
  if (!wrapper) return;
  const ds = getDrawingState(drawingId);

  wrapper.className = 'drawing-block-wrapper' + (ds.editing ? ' editing' : '');

  const canvas = wrapper.querySelector('.drawing-canvas-inline');
  canvas.style.height = ds.height + 'px';

  // Render elements
  canvas.querySelectorAll('.canvas-element').forEach(e => e.remove());
  ds.elements.forEach(el => {
    const sel = el.id === ds.selectedElementId ? ' selected' : '';
    const color = el.strokeColor || colors[0];
    const bg = el.backgroundColor || 'transparent';
    const div = document.createElement('div');
    div.className = 'canvas-element' + sel;
    div.dataset.id = el.id;
    div.onclick = (e) => { e.stopPropagation(); if (ds.editing) selectDrawingElement(drawingId, el.id); };

    if (el.type === 'line') {
      div.style.cssText = `left:${el.x}px;top:${el.y}px;width:${el.width}px;height:2px;background:${color};border:none;border-radius:0;transform:rotate(${el.angle || 0}deg)`;
    } else {
      const borderRadius = el.type === 'ellipse' ? '50%' : '4px';
      div.style.cssText = `left:${el.x}px;top:${el.y}px;width:${el.width}px;height:${el.height}px;border-color:${color};background:${bg};border-radius:${borderRadius}`;
      const span = document.createElement('span');
      span.style.cssText = `color:${color};font-family:var(--font)`;
      span.textContent = el.type === 'rectangle' ? '‚ñ≠' : '‚óØ';
      div.appendChild(span);
    }
    canvas.appendChild(div);
  });

  // Update status bar
  const statusBar = wrapper.querySelector('.drawing-status-bar');
  statusBar.textContent = `${ds.elements.length} elements ¬∑ cursor: ${ds.historyState.undoCursor} / ${ds.historyState.actionCount} actions`;

  // Update undo/redo buttons
  const undoBtn = wrapper.querySelector('.btn-undo');
  const redoBtn = wrapper.querySelector('.btn-redo');
  if (undoBtn) undoBtn.disabled = ds.historyState.undoCursor < 0;
  if (redoBtn) redoBtn.disabled = ds.historyState.undoCursor >= ds.historyState.actionCount - 1;
}

// ===== BLOCK EDITOR =====

function renderBlocks() {
  const el = document.getElementById('block-editor');
  if (blocks.length === 0) {
    el.innerHTML = '<div class="empty">start typing ‚Äî or use the toolbar to add blocks</div>';
  } else {
    el.innerHTML = blocks.map(b => {
      const sel = b.id === selectedBlockId ? ' selected' : '';
      let inner = '';
      switch (b.type) {
        case 'paragraph':
          inner = `<p>${b.text}</p>`;
          break;
        case 'heading':
          inner = `<h${b.level}>${b.text}</h${b.level}>`;
          break;
        case 'list':
          const tag = b.ordered ? 'ol' : 'ul';
          inner = `<${tag}>${b.items.map(i => `<li>${i}</li>`).join('')}</${tag}>`;
          break;
        case 'drawing_ref':
          inner = renderDrawingBlockHTML(b.drawingId);
          break;
        case 'spacer':
          inner = `<div class="spacer-line"></div>`;
          break;
        case 'section':
          inner = `<span class="section-badge">‚äû section ¬∑ ${b.layout.lanes.length} lanes</span>`;
          break;
      }

      if (b.type === 'drawing_ref') {
        return inner; // Drawing blocks render their own wrapper
      }

      return `<div class="block${sel}" onclick="selectBlock('${b.id}')">
        <span class="handle">‚†ø</span>${inner}
      </div>`;
    }).join('');

    // Attach drawing resize handlers after DOM update
    blocks.forEach(b => {
      if (b.type === 'drawing_ref') {
        attachDrawingResize(b.drawingId);
      }
    });
  }
  document.getElementById('block-count').textContent = blocks.length;
  document.getElementById('doc-version').textContent = docVersion;
}

function renderDrawingBlockHTML(drawingId) {
  const ds = getDrawingState(drawingId);
  return `<div class="drawing-block-wrapper${ds.editing ? ' editing' : ''}" data-drawing-id="${drawingId}">
    <div class="drawing-canvas-inline" style="height:${ds.height}px" onclick="if(getDrawingState('${drawingId}').editing){getDrawingState('${drawingId}').selectedElementId=null;renderDrawingBlock('${drawingId}')}">
      <div class="drawing-view-overlay" onclick="event.stopPropagation();enterDrawingEdit('${drawingId}')"></div>
      <div class="drawing-click-hint">click to edit drawing</div>
    </div>
    <div class="drawing-float-toolbar">
      <button class="btn-undo" onclick="drawingUndo('${drawingId}')" title="Undo">‚Ü©</button>
      <button class="btn-redo" onclick="drawingRedo('${drawingId}')" title="Redo">‚Ü™</button>
      <div class="sep"></div>
      <button onclick="addShapeToDrawing('${drawingId}','rectangle')" title="Rectangle">‚ñ≠</button>
      <button onclick="addShapeToDrawing('${drawingId}','ellipse')" title="Ellipse">‚óØ</button>
      <button onclick="addShapeToDrawing('${drawingId}','line')" title="Line">‚ï±</button>
      <div class="sep"></div>
      <button onclick="deleteDrawingElement('${drawingId}')" title="Delete">‚úï</button>
      <div class="sep"></div>
      <button onclick="exitDrawingEdit('${drawingId}')" title="Done (Esc)">‚úì done</button>
    </div>
    <div class="drawing-status-bar">${ds.elements.length} elements ¬∑ cursor: ${ds.historyState.undoCursor} / ${ds.historyState.actionCount} actions</div>
    <div class="drawing-resize-handle" data-drawing-id="${drawingId}"></div>
  </div>`;
}

function attachDrawingResize(drawingId) {
  const handle = document.querySelector(`.drawing-resize-handle[data-drawing-id="${drawingId}"]`);
  if (!handle) return;
  handle.addEventListener('mousedown', (e) => {
    e.preventDefault();
    const ds = getDrawingState(drawingId);
    const startY = e.clientY;
    const startH = ds.height;

    function onMove(ev) {
      ds.height = Math.max(120, startH + (ev.clientY - startY));
      const canvas = document.querySelector(`[data-drawing-id="${drawingId}"] .drawing-canvas-inline`);
      if (canvas) canvas.style.height = ds.height + 'px';
    }
    function onUp() {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
    }
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  });

  // Re-render elements into the canvas after DOM creation
  renderDrawingBlock(drawingId);
}

function logBody(msg) {
  const el = document.getElementById('body-log');
  const time = new Date().toLocaleTimeString();
  el.innerHTML += `<div class="log-line"><span class="log-ts">${time}</span><span class="log-msg">${msg}</span></div>`;
  el.scrollTop = el.scrollHeight;
}

function selectBlock(id) {
  selectedBlockId = selectedBlockId === id ? null : id;
  renderBlocks();
}

function insertBlockAfter(block) {
  if (selectedBlockId) {
    const idx = blocks.findIndex(b => b.id === selectedBlockId);
    if (idx !== -1) {
      blocks = [...blocks.slice(0, idx + 1), block, ...blocks.slice(idx + 1)];
    } else {
      blocks = [...blocks, block];
    }
  } else {
    blocks = [...blocks, block];
  }
  docVersion++;
  selectedBlockId = block.id;
  renderBlocks();
}

function addParagraph() {
  const text = sampleParas[Math.floor(Math.random() * sampleParas.length)];
  const block = { id: makeId('p'), type: 'paragraph', text };
  insertBlockAfter(block);
  logBody('insert paragraph');
}

function addHeading() {
  const text = sampleHeadings[Math.floor(Math.random() * sampleHeadings.length)];
  const level = Math.ceil(Math.random() * 3);
  const block = { id: makeId('h'), type: 'heading', text, level };
  insertBlockAfter(block);
  logBody(`insert h${level}: "${text}"`);
}

function addList() {
  const block = {
    id: makeId('li'), type: 'list',
    items: ['First item', 'Second item', 'Third item'],
    ordered: Math.random() > 0.5,
  };
  insertBlockAfter(block);
  logBody('insert list');
}

function addDrawingBlock() {
  const drawingId = makeId('drawing');
  const block = { id: makeId('dr'), type: 'drawing_ref', drawingId };
  getDrawingState(drawingId); // initialize state
  insertBlockAfter(block);
  logBody(`insert drawing block: ${drawingId}`);
}

function addSpacer() {
  const block = { id: makeId('sp'), type: 'spacer' };
  insertBlockAfter(block);
  logBody('insert spacer');
}

function updateSelected() {
  if (!selectedBlockId) return;
  const block = blocks.find(b => b.id === selectedBlockId);
  if (!block) return;
  if (block.type === 'paragraph' || block.type === 'heading') {
    const newText = prompt('Edit text:', block.text);
    if (newText !== null) {
      blocks = blocks.map(b => b.id === selectedBlockId ? { ...b, text: newText } : b);
      docVersion++;
      renderBlocks();
      logBody(`update: "${newText.slice(0, 30)}‚Ä¶"`);
    }
  } else if (block.type === 'drawing_ref') {
    enterDrawingEdit(block.drawingId);
  }
}

function deleteSelected() {
  if (!selectedBlockId) return;
  const id = selectedBlockId;
  blocks = blocks.filter(b => b.id !== id);
  selectedBlockId = null;
  docVersion++;
  renderBlocks();
  logBody(`delete ${id}`);
}

function moveSelectedUp() {
  if (!selectedBlockId) return;
  const idx = blocks.findIndex(b => b.id === selectedBlockId);
  if (idx <= 0) return;
  const nb = [...blocks];
  [nb[idx - 1], nb[idx]] = [nb[idx], nb[idx - 1]];
  blocks = nb;
  docVersion++;
  renderBlocks();
  logBody('move up');
}

function moveSelectedDown() {
  if (!selectedBlockId) return;
  const idx = blocks.findIndex(b => b.id === selectedBlockId);
  if (idx === -1 || idx >= blocks.length - 1) return;
  const nb = [...blocks];
  [nb[idx], nb[idx + 1]] = [nb[idx + 1], nb[idx]];
  blocks = nb;
  docVersion++;
  renderBlocks();
  logBody('move down');
}

// ===== KEYBOARD SHORTCUTS =====

document.addEventListener('keydown', (e) => {
  // Don't intercept when typing in inputs/prompts
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

  if (currentPage === 'editor') {
    if (e.ctrlKey || e.metaKey) {
      switch (e.key.toLowerCase()) {
        case 'p': e.preventDefault(); addParagraph(); return;
        case 'h': e.preventDefault(); addHeading(); return;
        case 'l': e.preventDefault(); addList(); return;
        case 'd': e.preventDefault(); addDrawingBlock(); return;
        case 'e': e.preventDefault(); updateSelected(); return;
        case 'z':
          // Check if any drawing is being edited
          for (const id of Object.keys(drawingStates)) {
            if (drawingStates[id].editing) {
              e.preventDefault();
              if (e.shiftKey) drawingRedo(id);
              else drawingUndo(id);
              return;
            }
          }
          return;
      }
    }

    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (selectedBlockId) { e.preventDefault(); deleteSelected(); return; }
    }

    if (e.key === 'ArrowUp' && e.altKey) { e.preventDefault(); moveSelectedUp(); return; }
    if (e.key === 'ArrowDown' && e.altKey) { e.preventDefault(); moveSelectedDown(); return; }

    if (e.key === 'Escape') {
      // Exit drawing edit mode first
      for (const id of Object.keys(drawingStates)) {
        if (drawingStates[id].editing) { exitDrawingEdit(id); return; }
      }
      selectedBlockId = null;
      renderBlocks();
      return;
    }
  }
});

// ===== COMMENTS =====

function renderComments() {
  renderCommentList('comments-a', commentsA);
  renderCommentList('comments-b', commentsB);
}

function renderCommentList(id, comments) {
  const el = document.getElementById(id);
  if (comments.length === 0) {
    el.innerHTML = '<div class="empty">no comments yet</div>';
    return;
  }
  el.innerHTML = comments.map(c => `
    <div class="comment-thread">
      <span class="comment-author-name">${c.author}</span>
      <span class="comment-on">on ${c.anchor}</span>
      <div class="comment-body">${c.text}</div>
    </div>
  `).join('');
}

function addCommentA() {
  const text = sampleTexts[commentCounterA++ % sampleTexts.length];
  const c = { id: makeId('c'), author: 'üë© Alice', anchor: blocks.length > 0 ? blocks[Math.floor(Math.random() * blocks.length)].id : 'doc', text, createdAt: Date.now() };
  commentsA.push(c);
  if (commentsOnline) { commentsB.push(c); }
  else { pendingA.push(c); document.getElementById('sync-a').className = 'sync-badge pending'; document.getElementById('sync-a').textContent = 'pending'; }
  renderComments();
}

function addCommentB() {
  const text = sampleTexts[commentCounterB++ % sampleTexts.length];
  const c = { id: makeId('c'), author: 'üë® Bob', anchor: blocks.length > 0 ? blocks[Math.floor(Math.random() * blocks.length)].id : 'doc', text, createdAt: Date.now() };
  commentsB.push(c);
  if (commentsOnline) { commentsA.push(c); }
  else { pendingB.push(c); document.getElementById('sync-b').className = 'sync-badge pending'; document.getElementById('sync-b').textContent = 'pending'; }
  renderComments();
}

function syncComments() {
  pendingA.forEach(c => { if (!commentsB.find(x => x.id === c.id)) commentsB.push(c); });
  pendingB.forEach(c => { if (!commentsA.find(x => x.id === c.id)) commentsA.push(c); });
  pendingA = []; pendingB = [];
  document.getElementById('sync-a').className = 'sync-badge synced'; document.getElementById('sync-a').textContent = 'synced';
  document.getElementById('sync-b').className = 'sync-badge synced'; document.getElementById('sync-b').textContent = 'synced';
  commentsOnline = true;
  renderComments();
}

function goOffline() {
  commentsOnline = false;
  document.getElementById('sync-a').className = 'sync-badge offline'; document.getElementById('sync-a').textContent = 'offline';
  document.getElementById('sync-b').className = 'sync-badge offline'; document.getElementById('sync-b').textContent = 'offline';
}

function goOnline() { syncComments(); }

// ===== COLUMNS =====

let columnSections = [];

function renderColumns() {
  const el = document.getElementById('columns-area');
  if (columnSections.length === 0) {
    el.innerHTML = '<div class="empty-dashed">add a column layout below</div>';
    return;
  }
  el.innerHTML = columnSections.map(renderSection).join('');
}

function renderSection(sec) {
  return `<div class="columns-layout">
    ${sec.lanes.map(lane => `
      <div class="col-lane">
        <div class="col-lane-label">${lane.name}</div>
        ${lane.blocks.map(b => `<div class="col-lane-block">${b}</div>`).join('')}
        ${lane.nested ? renderSection(lane.nested) : ''}
      </div>
    `).join('')}
  </div>`;
}

function addTwoColumns() {
  columnSections.push({ id: makeId('s'), lanes: [
    { name: 'Lane A', blocks: ['Introduction text goes here', 'With supporting details'] },
    { name: 'Lane B', blocks: ['Sidebar content', 'Additional notes', 'Reference links'] },
  ]});
  renderColumns();
}

function addThreeColumns() {
  columnSections.push({ id: makeId('s'), lanes: [
    { name: 'Left', blocks: ['Navigation', 'Menu items'] },
    { name: 'Center', blocks: ['Main content area', 'Primary article text', 'With multiple paragraphs'] },
    { name: 'Right', blocks: ['Related articles', 'Tags & categories'] },
  ]});
  renderColumns();
}

function addNestedSection() {
  columnSections.push({ id: makeId('s'), lanes: [
    { name: 'Outer Left', blocks: ['Outer content'], nested: { id: makeId('s'), lanes: [
      { name: 'Inner A', blocks: ['Nested block 1'] },
      { name: 'Inner B', blocks: ['Nested block 2', 'More nesting'] },
    ]}},
    { name: 'Outer Right', blocks: ['Right column', 'Content here'] },
  ]});
  renderColumns();
}

// ===== EXPORT =====

function exportBundle() {
  const allDrawingIds = blocks.filter(b => b.type === 'drawing_ref').map(b => b.drawingId);
  const manifest = { version: '1.0', docId: 'doc-demo', createdAt: new Date().toISOString(), drawingIds: allDrawingIds };
  const bodySnapshot = { docId: 'doc-demo', version: docVersion, blocks };

  let drawingSections = '';
  allDrawingIds.forEach(did => {
    const ds = getDrawingState(did);
    const scene = { drawingId: did, elements: ds.elements, appState: {}, files: {} };
    drawingSections += `\nüé® drawings/${did}.scene.json (${ds.elements.length} elements)\n${JSON.stringify(scene, null, 2).slice(0, 300)}${ds.elements.length > 2 ? '\n  ...' : ''}\n`;
    drawingSections += `\nüìú drawings/${did}.history.jsonl (${ds.actions.length} actions)\n${ds.actions.slice(0, 2).map(a => JSON.stringify(a)).join('\n')}${ds.actions.length > 2 ? '\n...' : ''}\n`;
    drawingSections += `\n‚è± drawings/${did}.history_state.json\n${JSON.stringify(ds.historyState, null, 2)}\n`;
  });

  const preview = `üì¶ .paperlike bundle
${'‚ïê'.repeat(50)}

üìã manifest.json
${JSON.stringify(manifest, null, 2)}

üìÑ body.json (${blocks.length} blocks, version ${docVersion})
${JSON.stringify(bodySnapshot, null, 2).slice(0, 500)}${blocks.length > 3 ? '\n  ...' : ''}
${drawingSections}
üí¨ comments: ${commentsA.length} on device A`;

  document.getElementById('export-preview').textContent = preview;
}

function reimportBundle() {
  if (blocks.length === 0) {
    document.getElementById('export-preview').textContent = '‚ö†Ô∏è nothing to re-import ‚Äî add content first';
    return;
  }
  const allDrawingIds = blocks.filter(b => b.type === 'drawing_ref').map(b => b.drawingId);
  const checks = [
    ['body blocks', blocks.length, JSON.parse(JSON.stringify(blocks)).length],
    ['doc version', docVersion, JSON.parse(JSON.stringify(docVersion))],
  ];
  allDrawingIds.forEach(did => {
    const ds = getDrawingState(did);
    checks.push([`${did} elements`, ds.elements.length, JSON.parse(JSON.stringify(ds.elements)).length]);
    checks.push([`${did} actions`, ds.actions.length, JSON.parse(JSON.stringify(ds.actions)).length]);
    checks.push([`${did} cursor`, ds.historyState.undoCursor, JSON.parse(JSON.stringify(ds.historyState)).undoCursor]);
  });
  let r = `üì• re-import verification\n${'‚ïê'.repeat(50)}\n\n`;
  let ok = true;
  checks.forEach(([label, exp, act]) => {
    const pass = exp === act;
    if (!pass) ok = false;
    r += `${pass ? '‚úÖ' : '‚ùå'} ${label}: ${act} ${pass ? '(match)' : `(expected ${exp})`}\n`;
  });
  r += `\n${ok ? 'üéâ all checks passed ‚Äî state continuity verified!' : '‚ö†Ô∏è some checks failed'}`;
  document.getElementById('export-preview').textContent = r;
}

// ===== INIT =====

function initializeDemo() {
  const d1 = makeId('drawing');
  const d2 = makeId('drawing');

  blocks = [
    { id: makeId('h'), type: 'heading', text: 'Welcome to Paperlike', level: 1 },
    { id: makeId('p'), type: 'paragraph', text: 'Paperlike is a collaborative document editor where text and drawings live side by side. Click on any drawing to edit it ‚Äî shapes, undo/redo, and history are all per-drawing.' },
    { id: makeId('dr'), type: 'drawing_ref', drawingId: d1 },
    { id: makeId('p'), type: 'paragraph', text: 'Each drawing block has its own undo/redo history. You can resize drawings by dragging the handle at the bottom. Width automatically fills the available space.' },
    { id: makeId('h'), type: 'heading', text: 'Architecture Overview', level: 2 },
    { id: makeId('li'), type: 'list', items: [
      'Block-based editor with 6 block types',
      'Inline Excalidraw-style drawings',
      'CRDT comments for offline collaboration',
      'Recursive column sections',
      'Export/import .paperlike bundles',
    ], ordered: false },
    { id: makeId('sp'), type: 'spacer' },
    { id: makeId('h'), type: 'heading', text: 'Another Drawing Below', level: 3 },
    { id: makeId('p'), type: 'paragraph', text: 'Multiple drawings can exist in a single document. Each one is independent with its own elements and history.' },
    { id: makeId('dr'), type: 'drawing_ref', drawingId: d2 },
    { id: makeId('p'), type: 'paragraph', text: 'Keyboard shortcuts make everything fast: Ctrl+D inserts a new drawing, Ctrl+P adds a paragraph, Ctrl+Z undoes within an active drawing, and Esc exits drawing edit mode.' },
  ];
  docVersion = 11;

  // Add shapes to drawing 1
  const ds1 = getDrawingState(d1);
  ds1.height = 250;
  for (let i = 0; i < 5; i++) addShapeToDrawing(d1, ['rectangle', 'ellipse', 'line'][i % 3]);

  // Add shapes to drawing 2
  const ds2 = getDrawingState(d2);
  ds2.height = 180;
  for (let i = 0; i < 3; i++) addShapeToDrawing(d2, ['ellipse', 'rectangle'][i % 2]);

  // Exit edit mode for both drawings
  exitDrawingEdit(d1);
  exitDrawingEdit(d2);

  commentsA = [
    { id: makeId('c'), author: 'üë© Alice', anchor: blocks[0].id, text: 'Great title!', createdAt: Date.now() - 60000 },
    { id: makeId('c'), author: 'üë® Bob', anchor: blocks[1].id, text: 'Consider adding more detail about the sync protocol.', createdAt: Date.now() - 30000 },
  ];
  commentsB = [...commentsA];

  addTwoColumns();

  renderBlocks();
  renderComments();
}

initializeDemo();
</script>

</body>
</html>
